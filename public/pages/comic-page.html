<link rel="import" href="../lib/iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">
<link rel="import" href="../lib/iron-ajax/iron-ajax.html">
<link rel="import" href="../lib/iron-icons/iron-icons.html">
<link rel="import" href="../lib/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../lib/paper-dialog/paper-dialog.html">
<link rel="import" href="../lib/paper-input/paper-input.html">
<link rel="import" href="../lib/paper-material/paper-material.html">
<link rel="import" href="../lib/polymer/polymer.html">
<dom-module id="comic-page">
  <style>
    :host {
      display: block;
      background-color: black;
      min-height: 100%;
    }
    paper-material {
      padding: 10px;
    }
    #comics {
      max-width: 900px;
      margin: 0 auto;
      padding-bottom: 60px;
      background-color: white;
    }
    .right {
      float: right;
    }
    .left {
      float: left;
    }
    #nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: black;
      color: white;
      text-align: center;
    }
    #nav > span {
      position: relative;
      top: 1px;
    }
    .cached {
      display: none;
    }
    .info:active .cached {
      display: inherit;
    }
    .info:active .max {
      display: none;
    }
    paper-icon-button::shadow #ink {
      color: white !important;
    }
  </style>
  <template>
    <div id="comics">
    </div>
    <paper-material id="nav" elevation="1">
      <paper-icon-button class="left" icon="arrow-back" on-tap="prev"></paper-icon-button>
      <span class="info" on-down="updateCachedCount">
        <span>{{page}}</span>
        <span class="cached">
          (+<span>{{cachedCount}}</span>)
        </span>
        <span class="max">
          / <span>{{comic.max_idx}}</span>
        </span>
      </span>
      <paper-icon-button icon="settings" on-tap="openOptions"></paper-icon-button>
      <paper-icon-button icon="fullscreen" on-tap="fullscreen"></paper-icon-button>
      <paper-icon-button class="right" icon="arrow-forward" on-tap="next"></paper-icon-button>
    </paper-material>
    <paper-dialog id="options" with-backdrop>
      <h2>Comic Options</h2>
      <paper-input label="Number of Pages to Cache" type="number" value="{{toCacheCount}}"></paper-input>
      <paper-button on-tap="precache">precache</paper-button>
      <paper-button on-tap="clearOld">clear Old</paper-button>
    </paper-dialog>

    <iron-ajax
      auto
      url="{{computeImageURL(slug, page, 0)}}"
      handle-as="text"
      on-response="handleResponse"
      debounce-duration="300"></iron-ajax>
  </template>

</dom-module>
<script>
  var CACHE = {};
  Polymer({
    is: 'comic-page',

    ready: function() {
      this.window = window;

      this.loggedIn = !!window.localStorage.loggedIn;

      var hammertime = new Hammer(this);
      var self = this;
      hammertime.on('swiperight', function(ev) {
        console.log(ev);
        self.prev();
      });
      hammertime.on('swipeleft', function(ev) {
        console.log(ev);
        self.next();
      });
    },

    properties: {
      page: {
        type: Number,
        observer: 'savePage',
      },
      imageURL: {
        type: String,
        computed: 'computeImageURL(slug, page, 0)',
        observer: 'decache',
      },
      boundKeys: {
        type: Array,
        value: function() {
          return Object.keys(this.keyBindings).join(' ').split(' ');
        }
      },
      keyEventTarget: {
        type: Object,
        value: function() {
          return document.body;
        }
      },
      cachedCount: {
        value: 'Loading...',
      }
    },

    savePage: function(page) {
      var key = 'comic:'+this.slug;
      var self = this;
      window.localforage.getItem(key).then(function(comic) {
        var idx = parseInt(page, 10);
        comic.idx = idx;
        window.localforage.setItem(key, comic);
        self.comic = comic;
        if (comic.max_idx <= idx+1) {
          self.cacheComicPage(idx+1, true);
        }
        if (self.loggedIn) {
          $.post('api/markcomic', self.comic);
        }
      });
    },

    decache: function(url) {
      var self = this;
      window.localforage.getItem('comic-page:'+url).then(function(urls) {
        if (urls) {
          document.body.scrollTop = 0
          self.$.comics.innerHTML = urls;
          self.cleanHTML();
        }
      });
    },

    updateCachedCount: function() {
      var self = this;
      return self.countCached().then(function(cached) {
        console.log("cached", cached);
        self.cachedCount = cached;
        return cached;
      });
    },

    cleanHTML: function() {
      $('#comics table[width]').attr('width','');
    },

    computeImageURL: function(slug, page, offset) {
      var url = "api/comic?slug="+slug+"&p="+(parseInt(page) + offset);
      return url;
    },

    next: function() {
      this.nav(1);
    },

    prev: function() {
      this.nav(-1);
    },

    handleResponse: function(resp,req) {
      var url = new URL(req.xhr.responseURL);
      var relURL = url.pathname + url.search;
      var urls = req.xhr.response;
      var key = 'comic-page:'+relURL;
      window.localforage.setItem(key, urls);
      if (relURL.endsWith(this.imageURL)) {
        if (!urls) {
          this.nav(-1);
        } else {
          this.$.comics.innerHTML = urls;
          this.cleanHTML();
        }
      }
    },

    comicURL: function(comic) {
      return "#/comic/"+comic.slug+"/"+(comic.idx+1);
    },

    behaviors: [
      Polymer.IronA11yKeysBehavior
    ],

    keyBindings: {
      'left right': 'navHandler'
    },

    navHandler: function(e) {
      switch (e.detail.keyboardEvent.keyIdentifier) {
      case "Right":
        this.nav(1);
        break;
      case "Left":
        this.nav(-1);
        break;
      default:
        console.log('keyboard event', e.detail.keyboardEvent.keyIdentifier);
      }
    },

    nav: function(dir) {
      var newPage = parseInt(this.page) + dir;
      if (newPage >= 1 && newPage <= this.comic.max_idx) {
        window.location.hash = "#/comic/"+this.slug+"/"+();
      }
    },

    countCached: function() {
      var self = this;
      return window.localforage.keys().then(function(keys) {
        var keySet = new Set(keys);
        for (var i=(self.comic.idx+1); i<=self.comic.max_idx; i++) {
          var key = 'comic-page:' + self.computeImageURL(self.comic.slug, i, 0);
          if (!keySet.has(key)) {
            console.log('missing', key);
            return i - self.comic.idx - 1;
          }
        }
        return i - self.comic.idx;
      });
    },

    openOptions: function() {
      var self = this;
      setTimeout(function() {
        self.$$('paper-dialog').open();
      }, 100);
    },

    clearOld: function() {
      for (var i=0;i<this.comic.idx;i++) {
        var key = 'comic-page:'+this.computeImageURL(this.comic.slug, i, 0);
        window.localforage.removeItem(key);
      }
    },

    precache: function() {
      var self = this;
      this.updateCachedCount().then(function(cached) {
        self.toCacheCount -= self.cachedCount;
        self.cacheComicPage(self.comic.idx + self.cachedCount);
      });
    },

    cacheComicPage: function(page, once) {
      var count = parseInt(this.toCacheCount, 10);
      if (count <= 0 && !once) {
        this.toCacheCount = 0;
        return;
      }
      var self = this;
      var url = this.computeImageURL(this.comic.slug, page, 0);
      var key = "comic-page:"+url;
      console.log('cacheComicPage', page, count);
      window.localforage.getItem(key).then(function(cachedPage) {
        self.toCacheCount = count - 1;
        self.cachedCount += 1;
        if (cachedPage) {
          if (!once) {
            self.cacheComicPage(page + 1);
          }
        } else {
          $.get(url, function(resp) {
            window.localforage.setItem(key, resp);
            if (!once) {
              self.cacheComicPage(page + 1);
            }
          });
        }
      });
    },

    fullscreen: function() {
      var isFullscreen = document.fullScreen || document.mozFullScreen || document.webkitIsFullScreen;
      if (isFullscreen) {
        this.cancelFullScreen();
      } else {
        this.requestFullScreen();
      }
    },

    requestFullScreen: function() {
      var elem = document.documentElement;
      if (elem.requestFullscreen) {
        elem.requestFullscreen();
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
      } else if (elem.mozRequestFullScreen) {
        elem.mozRequestFullScreen();
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
      }
    },

    cancelFullScreen: function() {
      if (document.cancelFullScreen) {
        document.cancelFullScreen();
      } else if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      }
    }
  });
</script>
